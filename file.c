/*
 * Copyright (c) 2009	   Alpit Gupta
 * Copyright (c) 2003-2014 Stony Brook University
 * Copyright (c) 2003-2014 The Research Foundation of SUNY
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "amfs.h"
#include "ioctl.h"
#include <linux/list.h>

static LIST_HEAD(malstart);
static ssize_t amfs_read(struct file *file, char __user *buf,
size_t count, loff_t *ppos)
{
int err;
struct file *lower_file = NULL;
struct dentry *dentry  =  NULL;
int result;
struct patterndblist *curr = NULL;
struct list_head *pos = NULL;
void * value = NULL;
struct maldblist *male = NULL;
struct amfs_sb_info* amfs_sb_info_data = NULL;
struct list_head* head = NULL;

dentry = file->f_path.dentry;
amfs_sb_info_data = (struct amfs_sb_info *)dentry->d_inode->i_sb->s_fs_info;
head  =  amfs_sb_info_data->plist;

/* check the getxattr value, whether file is good or bad*/
value = kzalloc(strlen(BAD_FILE), GFP_KERNEL);
result = file->f_path.dentry->d_inode->i_op->getxattr(dentry, AMFS_BAD, value, strlen(BAD_FILE));

/* In case of bad file, quarantine and exit*/
if(strcmp(value, BAD_FILE) == 0){
err =  -EPERM;
kfree(value);
goto out;
}

lower_file  =  amfs_lower_file(file);
err  =  vfs_read(lower_file, buf, count, ppos);

/* update our inode atime upon a successful lower read */
if (err >=  0)
fsstack_copy_attr_atime(dentry->d_inode,
file_inode(lower_file));

/* Iterate through all the malware patterns, check if any exists in the read buffer*/
list_for_each(pos, head){
curr  =  list_entry(pos, struct patterndblist, next);
if(strstr(buf, curr->val) !=  NULL){
/* mark the file as bad*/
result = file->f_path.dentry->d_inode->i_op->setxattr(dentry, AMFS_BAD, BAD_FILE, strlen(BAD_FILE), 0);

/* add the name, dentry and corresponding malware pattern to the malware linked list*/
male  =  kzalloc(sizeof(struct maldblist), GFP_KERNEL);
male->malval = (char *)kzalloc(strlen(dentry->d_iname), GFP_KERNEL);
strcpy(male->malval, dentry->d_iname);

male->virusname = (char *)kzalloc(strlen(curr->val), GFP_KERNEL);
strcpy(male->virusname, curr->val);

male->dent = dentry;

list_add(&(male->malnext), &malstart);
err = -EPERM;
break;
}

}
out:
return err;
}


static ssize_t amfs_write(struct file *file, const char __user *buf,
size_t count, loff_t *ppos)
{
int err = 0;
struct file *lower_file;
struct dentry *dentry  =  file->f_path.dentry;
struct patterndblist *curr = NULL;
struct list_head *pos = NULL;

struct amfs_sb_info* amfs_sb_info_data = (struct amfs_sb_info *)dentry->d_inode->i_sb->s_fs_info;
struct list_head* head  =  amfs_sb_info_data->plist;

/* Iterate through all the malware patterns, check if any exists in the write buffer*/
list_for_each(pos, head)
{
curr  =  list_entry(pos, struct patterndblist, next);
if(strstr(buf, curr->val) !=  NULL)
goto out;
}


lower_file  =  amfs_lower_file(file);
err  =  vfs_write(lower_file, buf, count, ppos);
/* update our inode times+sizes upon a successful lower write */
if (err >=  0) {
fsstack_copy_inode_size(dentry->d_inode,
file_inode(lower_file));
fsstack_copy_attr_times(dentry->d_inode,
file_inode(lower_file));
}

out:
return err;
}


/* Below structure has been copied and modified from ecryptfs*/
struct amfs_getdents_callback {
struct dir_context ctx;
struct dir_context *caller;
struct super_block *sb;
int filldir_called;
int entries_written;
};

/* Below filldir has been copied and modified from ecryptfs*/
/* Inspired by generic filldir in fs/readdir.c */
static int
amfs_filldir(struct dir_context *ctx, const char *lower_name, int lower_namelen, loff_t offset, u64 ino, unsigned int d_type)
{
struct amfs_getdents_callback *buf  =
container_of(ctx, struct amfs_getdents_callback, ctx);
int rc;
struct list_head* malpos = NULL;
struct maldblist *malcurr;
/* Iterate through all the files containing malware, check if matches with the lower_name,
if yes don't list under the directory*/
list_for_each(malpos, &malstart)
{
malcurr  =  list_entry(malpos, struct maldblist, malnext);

if(strcmp(lower_name, malcurr->malval)  ==  0)
return 0;
}

buf->filldir_called++;
buf->caller->pos  =  buf->ctx.pos;

/* Encryption/decryption of file names and skipped and user directly*/
rc  =  !dir_emit(buf->caller, lower_name, lower_namelen, ino, d_type);

if (!rc)
buf->entries_written++;
return rc;
}

/* Below readdir function has been modified, referring ecryptfs so to call filldir func appropriately*/
static int amfs_readdir(struct file *file, struct dir_context *ctx)
{
int err;
struct file *lower_file  =  NULL;
struct dentry *dentry  =  file->f_path.dentry;

struct amfs_getdents_callback buf  =  {
.ctx.actor  =  amfs_filldir,
.caller  =  ctx,
.sb  =  dentry->d_inode->i_sb,
};

lower_file  =  amfs_lower_file(file);
err  =  iterate_dir(lower_file, &buf.ctx);
file->f_pos  =  lower_file->f_pos;
if (err >=  0)/* copy the atime */
fsstack_copy_attr_atime(dentry->d_inode,
file_inode(lower_file));
return err;
}


/* Function to be invoked by IOCTL commands*/
static long amfs_unlocked_ioctl(struct file *file, unsigned int cmd,
unsigned long arg)
{
long err  =  0;
struct file *filp = NULL;
struct file *fileOut = NULL;
mm_segment_t oldfs;
int bytes;
char *buff = NULL;
struct patterndblist *curr = NULL;
struct patterndblist *e = NULL;
struct list_head* pos = NULL;
struct list_head* head  =  NULL;
struct list_head* lHead  =  NULL;
char *userbuff;
int isDuplicate = 0;
long result;
long ret;
struct list_head* malpos = NULL;
struct list_head* q = NULL;
struct maldblist *malcurr = NULL;
int isFound = 0;
int isFail = 0;


struct amfs_sb_info* amfs_sb_info_data = (struct amfs_sb_info *)file->f_path.dentry->d_inode->i_sb->s_fs_info;

/* copying insert/delete malware pattern at kernel space*/
userbuff = (char *)kzalloc(strlen((char *)arg), GFP_KERNEL);
ret = copy_from_user(userbuff, (char *)arg, strlen((char *)arg));

if(ret!= 0)
{
err = -EPERM;
goto out;
}

/* switch case to handle add/delete/list functionalities*/
switch(cmd)
{
case ADD_IOCTL:

{
/* check for duplicate elements*/
head  =  amfs_sb_info_data->plist;
list_for_each(pos, head)
{
curr  =  list_entry(pos, struct patterndblist, next);
if(strcmp(curr->val, userbuff)  ==  0)
{
isDuplicate = 1;
err = -EPERM;
goto out;
}
}

/* if not duplicate, insert it to the pattern database*/
if(isDuplicate  ==  0)
{
filp  =  filp_open((char *)amfs_sb_info_data->patternFile, O_WRONLY|O_APPEND, 0);
if (!filp || IS_ERR(filp))
{
err = -EBADF;
goto out;
}

if (!filp->f_op->read)
{
err = -EBADF;
goto out;
}

oldfs  =  get_fs();
set_fs(KERNEL_DS);

bytes  =  filp->f_op->write(filp, userbuff, strlen(userbuff), &filp->f_pos);
bytes  =  filp->f_op->write(filp, "\n", 1, &filp->f_pos);

set_fs(oldfs);

head  =  amfs_sb_info_data->plist;
e  =  kzalloc(sizeof(struct patterndblist), GFP_KERNEL);

e->val = (char *)kzalloc(strlen(userbuff), GFP_KERNEL);
strncpy(e->val, (const char *)userbuff, strlen(userbuff));

list_add(&(e->next), head);
}

break;
}

case REMOVE_IOCTL:

{

filp  =  filp_open("tmp.txt", O_WRONLY|O_CREAT, 0);
if (!filp || IS_ERR(filp)) {
err = -EBADF;
goto out;
}

if (!filp->f_op->read)
{
err = -EBADF;
goto out;
}
head  =  amfs_sb_info_data->plist;
list_for_each_safe(pos, lHead, head)
{
curr  =  list_entry(pos, struct patterndblist, next);
if(strcmp(curr->val, userbuff) !=  0)
{

oldfs  =  get_fs();
set_fs(KERNEL_DS);
bytes  =  filp->f_op->write(filp, curr->val, strlen(curr->val), &filp->f_pos);
if(bytes<0)
{
err = -EPERM;
goto out;
}

bytes  =  filp->f_op->write(filp, "\n", 1, &filp->f_pos);
if(bytes<0)
{
err = -EPERM;
goto out;
}

set_fs(oldfs);
}
else
{
list_del(pos);
isFound = 1;
}

}

if(isFound == 0)
{
err = -EPERM;
goto out;
}

if(filp!= NULL)
{
fileOut = filp_open((char *)amfs_sb_info_data->patternFile, O_WRONLY, 0);

isFail = vfs_rename(filp->f_path.dentry->d_parent->d_inode, filp->f_path.dentry,
fileOut->f_path.dentry->d_parent->d_inode, fileOut->f_path.dentry, NULL, 0);

if(isFail!= 0)
{
err = -EFAULT;
goto out;
}

}


/* Iterate throuh quarantined files and compare coresponding malware and passed malware to the
function call, if matched mark it good and remove from the malware files list*/
list_for_each_safe(malpos, q, &malstart)
{
malcurr  =  list_entry(malpos, struct maldblist, malnext);

if(strcmp(malcurr->virusname, userbuff) == 0)
{
result = malcurr->dent->d_inode->i_op->setxattr(malcurr->dent, AMFS_BAD, GOOD_FILE, strlen(GOOD_FILE), 0);
list_del(malpos);
}

}

break;

}

case LIST_IOCTL:

{

filp  =  filp_open((char *)amfs_sb_info_data->patternFile, O_RDONLY, 0);
if (!filp || IS_ERR(filp)) {
err = -EBADF;
goto out;
}

if (!filp->f_op->read)
{
err = -EBADF;
goto out;
}

buff = (char *)kzalloc(PAGE_SIZE, GFP_KERNEL);

filp->f_pos  =  0;
oldfs  =  get_fs();
set_fs(KERNEL_DS);
bytes  =  filp->f_op->read(filp, buff, PAGE_SIZE, &filp->f_pos);
set_fs(oldfs);

head  =  amfs_sb_info_data->plist;
list_for_each(pos, head)
{
curr  =  list_entry(pos, struct patterndblist, next);
}

ret = copy_to_user((char *)arg, buff, PAGE_SIZE);
if(ret!= 0)
{
err = -EFAULT;
goto out;
}

break;
}

}

out:
{
if(isFail!= 0)
{
if (filp->f_path.dentry !=  NULL  && filp->f_path.dentry->d_parent->d_inode !=  NULL)
vfs_unlink(filp->f_path.dentry->d_parent->d_inode, filp->f_path.dentry, NULL);
}

if(fileOut!= NULL)
filp_close(fileOut, NULL);

if(filp!= NULL)
filp_close(filp, NULL);

}
return err;
}


#ifdef CONFIG_COMPAT
static long amfs_compat_ioctl(struct file *file, unsigned int cmd,
unsigned long arg)
{
long err  =  -ENOTTY;
struct file *lower_file;

lower_file  =  amfs_lower_file(file);

/* XXX: use vfs_ioctl if/when VFS exports it */
if (!lower_file || !lower_file->f_op)
goto out;
if (lower_file->f_op->compat_ioctl)
err  =  lower_file->f_op->compat_ioctl(lower_file, cmd, arg);

out:
return err;
}
#endif

static int amfs_mmap(struct file *file, struct vm_area_struct *vma)
{
int err  =  0;
bool willwrite;
struct file *lower_file;
const struct vm_operations_struct *saved_vm_ops  =  NULL;

/* this might be deferred to mmap's writepage */
willwrite  =  ((vma->vm_flags | VM_SHARED | VM_WRITE)  ==  vma->vm_flags);

/*
* File systems which do not implement ->writepage may use
* generic_file_readonly_mmap as their ->mmap op.  If you call
* generic_file_readonly_mmap with VM_WRITE, you'd get an -EINVAL.
* But we cannot call the lower ->mmap op, so we can't tell that
* writeable mappings won't work.  Therefore, our only choice is to
* check if the lower file system supports the ->writepage, and if
* not, return EINVAL (the same error that
* generic_file_readonly_mmap returns in that case).
*/
lower_file  =  amfs_lower_file(file);
if (willwrite && !lower_file->f_mapping->a_ops->writepage) {
err  =  -EINVAL;
printk(KERN_ERR "amfs: lower file system does not "
"support writeable mmap\n");
goto out;
}

/*
* find and save lower vm_ops.
*
* XXX: the VFS should have a cleaner way of finding the lower vm_ops
*/
if (!AMFS_F(file)->lower_vm_ops) {
err  =  lower_file->f_op->mmap(lower_file, vma);
if (err) {
printk(KERN_ERR "amfs: lower mmap failed %d\n", err);
goto out;
}
saved_vm_ops  =  vma->vm_ops; /* save: came from lower ->mmap */
}

/*
* Next 3 lines are all I need from generic_file_mmap.  I definitely
* don't want its test for ->readpage which returns -ENOEXEC.
*/
file_accessed(file);
vma->vm_ops  =  &amfs_vm_ops;

file->f_mapping->a_ops  =  &amfs_aops; /* set our aops */
if (!AMFS_F(file)->lower_vm_ops) /* save for our ->fault */
AMFS_F(file)->lower_vm_ops  =  saved_vm_ops;

out:
return err;
}

static int amfs_open(struct inode *inode, struct file *file)
{
int err  =  0;
struct file *lower_file  =  NULL;
struct path lower_path;

/* don't open unhashed/deleted files */
if (d_unhashed(file->f_path.dentry)) {
err  =  -ENOENT;
goto out_err;
}

file->private_data  =
kzalloc(sizeof(struct amfs_file_info), GFP_KERNEL);
if (!AMFS_F(file)) {
err  =  -ENOMEM;
goto out_err;
}

/* open lower object and link amfs's file struct to lower's */
amfs_get_lower_path(file->f_path.dentry, &lower_path);
lower_file  =  dentry_open(&lower_path, file->f_flags, current_cred());
path_put(&lower_path);
if (IS_ERR(lower_file)) {
err  =  PTR_ERR(lower_file);
lower_file  =  amfs_lower_file(file);
if (lower_file) {
amfs_set_lower_file(file, NULL);
fput(lower_file); /* fput calls dput for lower_dentry */
}
} else {
amfs_set_lower_file(file, lower_file);
}

if (err)
kfree(AMFS_F(file));
else
fsstack_copy_attr_all(inode, amfs_lower_inode(inode));
out_err:
return err;
}

static int amfs_flush(struct file *file, fl_owner_t id)
{
int err  =  0;
struct file *lower_file  =  NULL;

lower_file  =  amfs_lower_file(file);
if (lower_file && lower_file->f_op && lower_file->f_op->flush) {
filemap_write_and_wait(file->f_mapping);
err  =  lower_file->f_op->flush(lower_file, id);
}

return err;
}

/* release all lower object references & free the file info structure */
static int amfs_file_release(struct inode *inode, struct file *file)
{
struct file *lower_file;
void *value;
int result = 0;

/*mark the file as good file while release*/
value = kzalloc(strlen(BAD_FILE), GFP_KERNEL);
result = inode->i_op->getxattr(file->f_path.dentry, AMFS_BAD, value, strlen(BAD_FILE));
if(strcmp(value, BAD_FILE) == 0)
{
result = inode->i_op->setxattr(file->f_path.dentry, AMFS_BAD, GOOD_FILE, strlen(GOOD_FILE), 0);
kfree(value);
}


lower_file  =  amfs_lower_file(file);
if (lower_file) {
amfs_set_lower_file(file, NULL);
fput(lower_file);
}

kfree(AMFS_F(file));
return 0;
}

static int amfs_fsync(struct file *file, loff_t start, loff_t end,
int datasync)
{
int err;
struct file *lower_file;
struct path lower_path;
struct dentry *dentry  =  file->f_path.dentry;

err  =  __generic_file_fsync(file, start, end, datasync);
if (err)
goto out;
lower_file  =  amfs_lower_file(file);
amfs_get_lower_path(dentry, &lower_path);
err  =  vfs_fsync_range(lower_file, start, end, datasync);
amfs_put_lower_path(dentry, &lower_path);
out:
return err;
}

static int amfs_fasync(int fd, struct file *file, int flag)
{
int err  =  0;
struct file *lower_file  =  NULL;

lower_file  =  amfs_lower_file(file);
if (lower_file->f_op && lower_file->f_op->fasync)
err  =  lower_file->f_op->fasync(fd, lower_file, flag);

return err;
}

static ssize_t amfs_aio_read(struct kiocb *iocb, const struct iovec *iov,
unsigned long nr_segs, loff_t pos)
{
int err  =  -EINVAL;
struct file *file, *lower_file;

file  =  iocb->ki_filp;
lower_file  =  amfs_lower_file(file);
if (!lower_file->f_op->aio_read)
goto out;
/*
* It appears safe to rewrite this iocb, because in
* do_io_submit@fs/aio.c, iocb is a just copy from user.
*/
get_file(lower_file); /* prevent lower_file from being released */
iocb->ki_filp  =  lower_file;
err  =  lower_file->f_op->aio_read(iocb, iov, nr_segs, pos);
iocb->ki_filp  =  file;
fput(lower_file);
/* update upper inode atime as needed */
if (err >=  0 || err  ==  -EIOCBQUEUED)
fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
file_inode(lower_file));
out:
return err;
}

static ssize_t amfs_aio_write(struct kiocb *iocb, const struct iovec *iov,
unsigned long nr_segs, loff_t pos)
{
int err  =  -EINVAL;
struct file *file, *lower_file;
file  =  iocb->ki_filp;
lower_file  =  amfs_lower_file(file);
if (!lower_file->f_op->aio_write)
goto out;
/*
* It appears safe to rewrite this iocb, because in
* do_io_submit@fs/aio.c, iocb is a just copy from user.
*/
get_file(lower_file); /* prevent lower_file from being released */
iocb->ki_filp  =  lower_file;
err  =  lower_file->f_op->aio_write(iocb, iov, nr_segs, pos);
iocb->ki_filp  =  file;
fput(lower_file);
/* update upper inode times/sizes as needed */
if (err >=  0 || err  ==  -EIOCBQUEUED) {
fsstack_copy_inode_size(file->f_path.dentry->d_inode,
file_inode(lower_file));
fsstack_copy_attr_times(file->f_path.dentry->d_inode,
file_inode(lower_file));
}
out:
return err;
}

/*
* Wrapfs cannot use generic_file_llseek as ->llseek, because it would
* only set the offset of the upper file.  So we have to implement our
* own method to set both the upper and lower file offsets
* consistently.
*/
static loff_t amfs_file_llseek(struct file *file, loff_t offset, int whence)
{
int err;
struct file *lower_file;

err  =  generic_file_llseek(file, offset, whence);
if (err < 0)
goto out;

lower_file  =  amfs_lower_file(file);
err  =  generic_file_llseek(lower_file, offset, whence);

out:
return err;
}

/*
* Wrapfs read_iter, redirect modified iocb to lower read_iter
*/
ssize_t
amfs_read_iter(struct kiocb *iocb, struct iov_iter *iter)
{
int err;
struct file *file  =  iocb->ki_filp, *lower_file;

lower_file  =  amfs_lower_file(file);
if (!lower_file->f_op->read_iter) {
err  =  -EINVAL;
goto out;
}

get_file(lower_file); /* prevent lower_file from being released */
iocb->ki_filp  =  lower_file;
err  =  lower_file->f_op->read_iter(iocb, iter);
iocb->ki_filp  =  file;
fput(lower_file);
/* update upper inode atime as needed */
if (err >=  0 || err  ==  -EIOCBQUEUED)
fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
file_inode(lower_file));
out:
return err;
}

/*
* Wrapfs write_iter, redirect modified iocb to lower write_iter
*/
ssize_t
amfs_write_iter(struct kiocb *iocb, struct iov_iter *iter)
{
int err;
struct file *file  =  iocb->ki_filp, *lower_file;

lower_file  =  amfs_lower_file(file);
if (!lower_file->f_op->write_iter) {
err  =  -EINVAL;
goto out;
}

get_file(lower_file); /* prevent lower_file from being released */
iocb->ki_filp  =  lower_file;
err  =  lower_file->f_op->write_iter(iocb, iter);
iocb->ki_filp  =  file;
fput(lower_file);
/* update upper inode times/sizes as needed */
if (err >=  0 || err  ==  -EIOCBQUEUED) {
fsstack_copy_inode_size(file->f_path.dentry->d_inode,
file_inode(lower_file));
fsstack_copy_attr_times(file->f_path.dentry->d_inode,
file_inode(lower_file));
}
out:
return err;
}

const struct file_operations amfs_main_fops  =  {
.llseek =  generic_file_llseek,
.read =  amfs_read,
.write =  amfs_write,
.unlocked_ioctl =  amfs_unlocked_ioctl,
#ifdef CONFIG_COMPAT
.compat_ioctl =  amfs_compat_ioctl,
#endif
.mmap =  amfs_mmap,
.open =  amfs_open,
.flush =  amfs_flush,
.release =  amfs_file_release,
.fsync =  amfs_fsync,
.fasync =  amfs_fasync,
.aio_read =  amfs_aio_read,
.aio_write =  amfs_aio_write,
.read_iter =  amfs_read_iter,
.write_iter =  amfs_write_iter,
};

/* trimmed directory options */
const struct file_operations amfs_dir_fops  =  {
.llseek =  amfs_file_llseek,
.read =  generic_read_dir,
.iterate =  amfs_readdir,
.unlocked_ioctl =  amfs_unlocked_ioctl,
#ifdef CONFIG_COMPAT
.compat_ioctl =  amfs_compat_ioctl,
#endif
.open =  amfs_open,
.release =  amfs_file_release,
.flush =  amfs_flush,
.fsync =  amfs_fsync,
.fasync =  amfs_fasync, };
