/*
 * Copyright (c) 2009	   Alpit Gupta
 * Copyright (c) 2003-2014 Stony Brook University
 * Copyright (c) 2003-2014 The Research Foundation of SUNY
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <stdio.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include "ioctl.h"
#include <asm/unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <string.h>


int main(int argc, char *argv[]){

	int c;
	long ret= 0;

	/* buffer storage to store the malware item needs to delete/add */
	char buf[4096];

	/* mount point value*/
	char mnt[256];

	int fd = -1;


	/* parsing command line argument to the user level variables*/
	while ((c = getopt(argc, argv, "alrh")) != -1)
	{
	  	switch(c)
	  	{
	  		/* Addition of malware pattern through IOCTL*/
		  	case 'a':

		  		/* there has to be two argumnets, new malware pattern and  mountpoint */
		  		if(argc!=(optind+2))
				{
					perror("Error occured: wrong mount point");
					return -1;
				}

				/* New malware pattern length should not be greater than 256*/
				if(strlen(argv[optind])>256)
				{
					perror("Error occured: Malware pattern size is greater than 256 characters");
					return -1;
				}

				/* mount point length should not be greater than 256*/
				if(strlen(argv[optind +1])>256)
				{
					perror("Error occured: Mount point path size is greater than 256 characters");
					return -1;
				}

				 memset(&buf,0,sizeof(buf));
				 memset(&mnt,0,sizeof(mnt));

				 strcpy(buf,argv[optind]);
				 strcpy(mnt,argv[optind + 1]);

				 if ((fd = open(mnt, O_RDONLY)) < 0) {
					perror("Error occured while accessing mount point");
					return -1;
				}

				/* Actual IOCTL call to add new malware pattern*/
				 ret=ioctl(fd, ADD_IOCTL,buf);

			break;

			/* list down all the malware patterns to the user*/
			case 'l':

				/* there has to be only one argumnet,  mountpoint */
				if(argc!=(optind+1))
				{
					perror("Error occured: wrong mount point");
					return -1;
				}

				/* New malware pattern length should not be greater than 256*/
				if(strlen(argv[optind])>256)
				{
					perror("Error occured: Mount point path size is greater than 256 characters");
					return -1;
				}

				 memset(&mnt,0,sizeof(mnt));
				 memset(&buf,0,sizeof(buf));

				 strcpy(mnt,argv[optind]);

				 if ((fd = open(mnt, O_RDONLY)) < 0) {
					perror("Error occured while accessing mount point");
					return -1;
				}

				/* Actual IOCTL call to list down malware entries*/
				ret=ioctl(fd, LIST_IOCTL, buf);
				if(ret>=0)
					fprintf(stdout, "List of malware patterns: \n%s",buf);

			break;

			/* remove any malware pattern if it already exists*/
			case 'r':

				/* there has to be two argumnets, new malware pattern and mountpoint */
				if(argc!=(optind+2))
				{
					perror("Error occured: wrong mount point");
					return -1;
				}

				/* New malware pattern length should not be greater than 256*/
				if(strlen(argv[optind])>256)
				{
					perror("Error occured: Malware pattern size is greater than 256 characters");
					return -1;
				}

				/* mount point length should not be greater than 256*/
				if(strlen(argv[optind +1])>256)
				{
					perror("Error occured: Mount point path size is greater than 256 characters");
					return -1;
				}

				memset(&buf,0,sizeof(buf));
				memset(&mnt,0,sizeof(mnt));

				strcpy(buf,argv[optind]);
				strcpy(mnt,argv[optind + 1]);

				if ((fd = open(mnt, O_RDONLY)) < 0) {
					perror("Error occured while accessing mount point");
					return -1;
				}

				/* Actual IOCTL call to remove any malware pattern, if exists*/
				ret=ioctl(fd, REMOVE_IOCTL, buf);

			break;

			case 'h':
			     fprintf(stdout, "Check for Malware pattern insert/remove along with mount point details\n");
				 return -1;

			default:
			      break;
		}

		/* return and print error msg in case of any failure*/
		if(ret<0)
		{
			perror("Error");
			return -1;
		}

	}

	/* return success*/
	return ret;

}
