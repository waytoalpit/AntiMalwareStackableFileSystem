/*
 * Copyright (c) 2009	   Alpit Gupta
 * Copyright (c) 2003-2014 Stony Brook University
 * Copyright (c) 2003-2014 The Research Foundation of SUNY
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "amfs.h"
#include <linux/module.h>
#include <linux/list.h>

 static LIST_HEAD(headstart);


/*
 * There is no need to lock the amfs_super_info's rwsem as there is no
 * way anyone can have a reference to the superblock at this point in time.
 */
 static int amfs_read_super(struct super_block *sb,  void *raw_data,  int silent) 
{
 int err  =  0;
 struct super_block *lower_sb;
 struct path lower_path;
 struct inode *inode;
 char * patternFileName = NULL;
 struct file *filp;
 mm_segment_t oldfs;
 int bytes;
 char *buf;
 struct amfs_pattern* amfs_patt;
 char *dev_name = NULL;
 struct patterndblist *e = NULL;
 char *line  =  NULL;

 amfs_patt = (struct amfs_pattern*)raw_data;
 dev_name  =  (char *)amfs_patt->lower_path_name;

 if (!dev_name) {
 printk(KERN_ERR
 "amfs: read_super: missing dev_name argument\n");
 err  =  -EINVAL;
 goto out;
 }
/* parse lower path */
 err  =  kern_path(dev_name,  LOOKUP_FOLLOW | LOOKUP_DIRECTORY, 
 &lower_path);
 if (err) {
 printk(KERN_ERR"amfs: error accessing "
 "lower directory '%s'\n",  dev_name);
 goto out_free;
 }

/* allocate superblock private data */
 sb->s_fs_info  =  kzalloc(sizeof(struct amfs_sb_info),  GFP_KERNEL);
 if (!AMFS_SB(sb)) {
 printk(KERN_CRIT "amfs: read_super: out of memory\n");
 err  =  -ENOMEM;
 goto out_free;
 }

 patternFileName =  (char *)amfs_patt->patternFile;
 buf = (char *)kzalloc(PAGE_SIZE,  GFP_KERNEL);
 if (!buf) {
 err  =  -ENOMEM;
 goto out;
 }

 filp  =  filp_open(patternFileName,  O_RDONLY,  0);
 if (!filp || IS_ERR(filp)) {
 err  =  -ENOMEM;
 kfree(buf);
 goto out;
 }

 if (!filp->f_op->read) {
 err  =  -EIO;
 kfree(buf);
 goto out;
 }

 filp->f_pos  =  0;
 oldfs  =  get_fs();
 set_fs(KERNEL_DS);

 while((bytes  =  filp->f_op->read(filp,  buf,  PAGE_SIZE,  &filp->f_pos))>0) {
 set_fs(oldfs);
 while((line = strsep(&buf, "\n\0"))!= NULL) {
 if(!strcmp(line,  ""))
 continue;

 e  =  kzalloc(sizeof(struct patterndblist),  GFP_KERNEL);
 e->val = (char *)kzalloc(strlen(line),  GFP_KERNEL);

 strcpy(e->val, (const char *)line);
 e->val  =  line;

 list_add(&(e->next), &headstart);
 }

 }

 filp_close(filp,  NULL);
 kfree(buf);

/* set the lower superblock field of upper superblock */
 lower_sb  =  lower_path.dentry->d_sb;
 atomic_inc(&lower_sb->s_active);
 amfs_set_lower_super(sb,  lower_sb,  &headstart,  patternFileName);


   /* inherit maxbytes from lower file system */
 sb->s_maxbytes  =  lower_sb->s_maxbytes;

/*
 * Our c/m/atime granularity is 1 ns because we may stack on file
 * systems whose granularity is as good.
 */
 sb->s_time_gran  =  1;

 sb->s_op  =  &amfs_sops;

/* get a new inode and allocate our root dentry */
 inode  =  amfs_iget(sb,  lower_path.dentry->d_inode);
 if (IS_ERR(inode)) {
 err  =  PTR_ERR(inode);
 goto out_sput;
 }
 sb->s_root  =  d_make_root(inode);
 if (!sb->s_root) {
 err  =  -ENOMEM;
 goto out_iput;
 }
 d_set_d_op(sb->s_root,  &amfs_dops);

/* link the upper and lower dentries */
 sb->s_root->d_fsdata  =  NULL;
 err  =  new_dentry_private_data(sb->s_root);
 if (err)
 goto out_freeroot;

/* if get here: cannot have error */

/* set the lower dentries for s_root */
 amfs_set_lower_path(sb->s_root,  &lower_path);

/*
 * No need to call interpose because we already have a positive
 * dentry,  which was instantiated by d_make_root.  Just need to
 * d_rehash it.
 */
 d_rehash(sb->s_root);
 if (!silent)
 printk(KERN_INFO
 "amfs: mounted on top of %s type %s\n", 
 dev_name,  lower_sb->s_type->name);

goto out; /* all is well */


/* no longer needed: free_dentry_private_data(sb->s_root); */
 out_freeroot:
 dput(sb->s_root);
 out_iput:
 iput(inode);
 out_sput:
/* drop refs we took earlier */
 atomic_dec(&lower_sb->s_active);
 kfree(AMFS_SB(sb));
 sb->s_fs_info  =  NULL;
 out_free:
 path_put(&lower_path);

 out:
 return err;
}

struct dentry *amfs_mount(struct file_system_type *fs_type,  int flags, 
const char *dev_name,  void *raw_data) {

struct amfs_pattern *amfs_pattern_data;
char *raw_data_name;
int cnt = 0;
int pattern_name_length = 0;
int i = 0;
long ret = 0;

amfs_pattern_data = (struct amfs_pattern *)kzalloc(sizeof(struct amfs_pattern),  GFP_KERNEL);
if (!amfs_pattern_data)
ret = -ENOMEM;

raw_data_name = (char *) raw_data;
pattern_name_length = strlen(raw_data_name);

while (*raw_data_name != '=') {
cnt++;
raw_data_name++;
}

raw_data_name++;
pattern_name_length = pattern_name_length-cnt;
amfs_pattern_data->patternFile  =  (char *)kzalloc(pattern_name_length,  GFP_KERNEL);

if (!amfs_pattern_data->patternFile)
ret = -ENOMEM;

while(*raw_data_name != '\0') {
amfs_pattern_data->patternFile[i++] = *raw_data_name;
raw_data_name++;
}


amfs_pattern_data->lower_path_name  =  (void *) dev_name;

return mount_nodev(fs_type,  flags,  amfs_pattern_data, 
amfs_read_super);
}

static struct file_system_type amfs_fs_type  =  {
.owner =  THIS_MODULE, 
.name =  AMFS_NAME, 
.mount =  amfs_mount, 
.kill_sb =  generic_shutdown_super, 
.fs_flags =  0, 
};
MODULE_ALIAS_FS(AMFS_NAME);

static int __init init_amfs_fs(void) {
int err;

pr_info("Registering amfs " AMFS_VERSION "\n");

err  =  amfs_init_inode_cache();
if (err)
goto out;
err  =  amfs_init_dentry_cache();
if (err)
goto out;
err  =  register_filesystem(&amfs_fs_type);
out:
if (err) {
amfs_destroy_inode_cache();
amfs_destroy_dentry_cache();
}
return err;
}

static void __exit exit_amfs_fs(void) {
amfs_destroy_inode_cache();
amfs_destroy_dentry_cache();
unregister_filesystem(&amfs_fs_type);
pr_info("Completed amfs module unload\n");
}

MODULE_AUTHOR("Erez Zadok,  Filesystems and Storage Lab,  Stony Brook University"
" (http://www.fsl.cs.sunysb.edu/)");
MODULE_DESCRIPTION("AMFS " AMFS_VERSION
" (http://amfs.filesystems.org/)");
MODULE_LICENSE("GPL");

module_init(init_amfs_fs);
module_exit(exit_amfs_fs);
